## 代码阅读

fa：总结是按原文目录的，主要考虑，需要的地方摘录或总结，其他关键点由看者感兴趣点再另行谷歌查阅。
fa：如果你想要从其它大的项目中，不论自底向上学习细节，还是自顶向下学习构架，请先翻开这本书。～嘿。

### 目录
*	木有新版，只有老版的电子书。
［我的观点是：技术书既要有商品属性，也要有free流通属性。作者本身，本该有开源精神。有收获的人，也应当注重分享。］

*	[0. 序言&前言](#0)
*	[1. 为啥要阅读代码？](#1)
*	[2. 基本编程元素](#2)
*	[3. 高级C数据类型](#3)
*	[4. C的数据结构](#4)
*	[5. 高级控制流程](#5)
*	[6. 应对大项目](#6)
*	[7. 编码规范和约定](#7)
*	[8. 文档](#8)
*	[9. 架构](#9)
*	[10. 代码阅读工具](#10)
*	[11. 代码阅读箴言](#11)

<h3 id="0">序言&前言</h3>

*	代码阅读是消除程序中存在问题的最有效方式之一。
*	维护，是软件开发令人生厌的远亲。
*	这是一本，实用主义的书。

*	代码阅读范畴关注点：程序结构、数据类型、数据结构、控制流程、项目组织、代码规范、文档与构架。

<h3 id="1">为啥要阅读代码？</h3>
*	软件开发过程中，40%到70%的工作量是在系统首次编写完投入的，这些工作总是包括阅读、理解和修改原始代码。
*	软件复用越发被重视，高的人员流动率，开源开始、合作开发工作（包括外包、代码走查和极限编程）的重要性。
*	基于以上两点，无论代码是否易读，它们终究需要被人们阅读。

*	通过阅读本书：

		1. 能够阅读理解重要软件的代码
		2. 理解很多重要的软件开发思想
		3. 拥有阅读大多数重要的高级（或低级）编程语言的能力
		4. 理解实际软件项目的复杂性
*	以上也将成为自我评估的模糊标准！

*	工程师总是倾向于揭开盖子查看一下事物的内部结构。去粗取精、提取复用。
*	自问：“我正在阅读的代码真的是最好的吗？”
*	（可能）有趣且尚不了解的部分：语言特性、应用程序编程接口（sdk）、算法、数据结构、架构和设计模式。
*	要清楚自己在找什么：是一个系统调用、一种算法、一段代码，还是一种架构？设计一种发现目标代码的策略。定位到目标代码后，劈开不相关的部分，对它进行研究分析，必要时抽出为己用，这是一项必备技能。

*	代码演进中的阅读代码（不同的目的有不同的阅读策略）
	1. 修复缺陷
	2. 增加新功能

			首要任务是，找到实现类似特性的代码，整改以形成合适的模板。
	3. 修改现有特性

			首先找到该特性，底层实现代码。
	4. 调整代码使其适应新的环境和需求

			可能只需要关注不同的编译环境。也可能需要接口适配。
	5. 重构以加强代码的非功能性质量

<h3 id="2">基本编程元素</h3>
1. 函数和全局变量
2. while循环、条件和块
3. for 循环

		可选策略：自底向上和自顶向下的分析（调用关系、继承关系、数据流、控制流）、试探发、检查注释和外部文档。

		> 描述for语句的三个部分是表达式，而非语句
		> 在多数情形下，无限循环用来表达循环开始或结束时退出条件无法确定的呃循环

4. break和continue语句

		> 在Java程序中，break和continue可以接一个标记标志符（label identifier）

5. 字符和布尔表达式

		> 许多现代语言中，布尔表达式只对需要的部分进行求值。

6. goto语句
7. 局部重构

		> 在阅读由自己控制的代码时，要养成添加注释的习惯。

8. do循环和整数表达式
9. 再论控制结构

		> 奖惩：既要奖励顶点，也要奖励指数。文化：既要要想顶点进发，也要有高指数的激励。
		> 人们在设计傻瓜系统时常犯的错误就是低估了傻瓜的能力。

<h3 id="3">高级C数据类型</h3>
1. 指针（用法如下）

		> 创建链式数据结构
		> 引用动态分配的数据结构
		> 实现引用调用
		> 访问和遍历数据集合
		> 传递数组参数
		> 作为函数的引用
		> 作为其他值的别名（原因如下）
			>> 效率上的考虑
			>> 引用静态初始化的数据
			>> 全局环境中实现变量引用语义
		> 表示字符串
		> 直接访问系统内存

2. 结构体（用法如下）

		> 包含不同的数据并将其作为整体使用
		> 使函数可以返回多个结果
		> 创建链表类型的数据结构
		> 映射硬件设备、网络、存储媒介上的数据组织方式
		> 实现抽象数据类型
		> 以面向对象方式编写代码

3. 联合体（用法如下）

		> 有效利用内存空间
		> 实现多态
		> 使用内部表征方式访问数据

4. 动态内存分配
5. typedef声明

<h3 id="4">C的数据结构</h3>
	*	数据内部组织形式对（作用于数据上的）算法而言十分重要。

1. 向量
2. 矩阵和表
3. 栈
4. 图

<h3 id="5">高级控制流程</h3>
1. 递归
2. 异常机制
3. 并行性
4. 信号
5. 非局部跳转
6. 宏替换

<h3 id="6">应对大项目</h3>
1. 设计和实现技术
	*	可视化的软件过程和约束准则：用jira进行敏捷迭代管理、缺陷管理，用jenkins进行持续构建等
	*	重要的架构
	*	尽可能的分解（该讨论在实现层）
	*	对跨平台支持
	*	面向对象技术
	*	运算符重载
	*	库、组件和进程：在更大的粒度上，大型系统常被分解为不同的对象模块库、可重用组件等。
	*	领域专用及定制的语言和工具
	* 预处理命令的积极使用（prefix 脚本也算）

2.项目的组织（很实用哦！）
	*	源码树通常能够反映项目的架构和软件处理结构。

3. 编译过程与makefile文件
4. 配置
5. 版本控制
6. 项目专用工具
7. 测试

<h3 id="7">编码规范和约定</h3>
这个没啥好说的，每个公司都有一套或N套编码规范。

<h3 id="8">文档</h3>
这个有必要说一下，可惜我经历的每个小公司，在过程性规范上的文档，实际的执行力都是，一只大鸭蛋。

1. 文档类型
	*	系统规格说明文档（System Specification Document）
	*	软件需求规格说明（Software Requirements Specification）
	*	设计规格说明（Design Specification)
	*	系统测试规格说明（System's Test Specification)

2. 文档中存在的问题？？
3. 常见的开源文档格式？？

<h3 id="9">架构</h3>
［点评：本章介绍了构成一个大项目的中常见的架构、模型，很有用］
1. 系统结构（集中式存储裤和分布式方法（centralized repository），数据流（data flow），面向对象（object oriented），分层架构（layered）［点评：这几点概念，书里面介绍的都不错］［控制复杂性！！］
		*	构建和理解复杂架构的一个中心元素师层次分解的概念：如何识别？源代码目录结构、静态或动态的过程调用图等等。
		* 切片

2. 控制模型
		*	事件驱动系统
		*	系统管理器
		*	状态转移

3. 元素包装
		*	模块（最常见的分解元素）
		*	命名空间
		*	对象（属性与方法、可见性、多态、运算符重载、泛型、抽象数据类型
		*	库（代码重用、封装、结构、构建过程优化、压缩代码大小、动态链接、进程和过滤器、组件）

4. 架构重用
		*	框架

<h3 id="10">代码阅读工具</h3>
略

<h3 id="11">代码阅读箴言</h3>
1. 导论
		*	应该养成一个习惯，时常花时间阅读别人编写的高质量代码。
		*	要有选择的阅读代码，并且要有自己的目标。是想学习新的模式、编码风格，还是满足某些需求的方法？
		*	要注意并重视代码中一些特殊的非功能性需求，这些需求可能会导致特定的实现风格。
		*	在当前代码上工作时，请与作者和维护人员进行必要的协调，以避免重复劳动或因此产生厌恶情绪。
		*	请将从开放源码软件中得到的软件中得到的益处看作是一项贷款；尽可能寻找个钟方式来回报开放源码社区。
		*	多数情形下，如果想要了解“别人会入锅完成这个功能？”，除了阅读代码，没有更好的方法。
		* 寻找bug的时候，请从问题的表现形式到问题的根源来分析代码。不要沿着不相关的路径。
		* 开发者应当充分利用调试器、编译器给出的警告货输出的符号代码、系统调用跟踪器、数据库结构化查询语言的日志机制、包转储工具和windows的消息侦查程序定位bug。
		*	对于那些大型的且组织良好的系统，开发者只需要最低限度了解其全部功能，就能够对它作出修改。
		*	在向系统中增加新功能时，首要的任务就是找到实现类似特性的代码，将它作为待实现功能的模板。
		*	从特性的功能描述到代码实现，可以循着字符串消息或使用关键词来搜索代码。
		*	在移植代码或修改接口时，可以通过编译器直接定位问题涉及的返回，从而减少代码阅读量。
		*	进行重构时，从一个能够正常工作的系统开始做起，确保结束时系统能够正常工作。一套恰当的测试用例可以帮助满足此项限制。
		*	阅读代码寻找重构机会时，先从系统的架构开始，然后逐步细化，能够获得最大的效益。
		*	代码的可重用性是一个很诱人，但难以掌握的思想；降低期望就不会感到失望。
		*	如果希望重用十分棘手、难以理解与分离的代码，可以试着寻找粒度更大一些的包，甚至其它代码。
		*	在复查软件系统时，要注意，系统是由很多部分组成的，不仅仅是执行语句。还要注意分析以下内容：文件盒目录结构、生成盒配置过程、用户界面和系统的文档。
2. 基本编程元素
		* 在第一次分析一个程序时，main是一个好的起点。
		*	嵌套 if-else if-...-else 序列可以看做是由互斥选择项组成的选择结构。
		*	有时，如果想了解程序在某一方面的功能，运行它可能比阅读代码更恰当。
		*	在分析重要的程序时，最好先识别出重要的组成部分。
		*	开发者应了解局部的命名约定，并利用它们来猜测变量和函数的功能用途。
		*	当基于猜测修改代码时，应该设计能够验证最初假设的过程。这个过程可能包括用编译器进行检查、引入断言或者执行恰当的测试用例。
		*	理解代码的某一部分，可能有助于理解余下的代码。
		*	解决困难的代码要从容易的部分入手。
		*	要养成遇到库元素就去阅读相关文档的习惯：这将会增强你阅读和编写代码的能力。
		*	代码阅读有许多可选择的策略：自底向上和自顶向下的分析、应用试探法和检查注释和外部文档，应该依据问题的需要尝试所有这些方法。
		*	for (i=0;i<n;i++) 形式的循环执行n次，其他任何形式都要小心。
		*	关于两项不等测试（其中一项包括相等条件）的比较表达式可以看做是区间成员测试。
		*	我们常常可以将表达式应用在样本数据上，借以了解它的含义。
		*	开发者可以使用 De Morgan 法则来简化复杂的逻辑表达式。
		*	在阅读逻辑乘表达式时，总是可以认为正在分析的表达式以左的表达式均为true；在阅读逻辑和表达式时，类似的，可以认为正在分析的表达式以左的表达式为false。
		*	重新组织所控制的代码，使之更为易读。
		*	将使用条件运算符 ?: 的表达式理解为if 代码。
		*	不需要为了效率牺牲代码的可读性。
		*	高效的算法和特殊的优化确实有可能使得代码更为复杂，从而更难理解，但这并不意味着使代码更为紧凑和不易读会提高它的效率。
		*	创造性的代码布局可用来提高代码的易读性
		*	我们可以使用空格、临时变量和括号提高表达式的可读性。（也可以在同一个方法中适当用大括号，取代空行，来代表不同功能的代码块。该注释的，还是要注释的！）
		*	在阅读所控制的代码时，应养成添加注释的习惯。
		*	41

3.
